<!DOCTYPE html>
<html>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ TeX: { extensions: ["AMSmath.js", "AMSsymbols.js"] }});
  MathJax.Hub.Config({
  TeX: {
    Macros: {
      md: "{\\text{d}}",
      dbar: "{\\text{d}}",
      bold: ["{\\bf #1}",1],
      Abs: ['\\left\\lvert #2 \\right\\rvert_{\\text{#1}}', 2, ""]
    }
  }
});
</script>
  <head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-106001791-2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-106001791-2');
  </script>
  
  <meta name="google-site-verification" content="dW5mXMbkY4MK952APZMO3_VkJwk9q6Rv1O8KgPZVidE" />
  <script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({ TeX: { extensions: ["AMSmath.js", "AMSsymbols.js"] }});
  MathJax.Hub.Config({
  TeX: {
    Macros: {
      md: "{\\text{d}}",
      dbar: "{\\text{d}}",
      bold: ["{\\bf #1}",1],
      Abs: ['\\left\\lvert #2 \\right\\rvert_{\\text{#1}}', 2, ""]
    	}
  	}
	});
	</script>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Towards Machine Learning</title>
  <meta name="description" content="Autoencoder      花式解释AutoEncoder与VAE - Sherlock的文章 - 知乎: 其实AE或者VAE的隐藏层（embedding layer）就是从input中提取出的精华特征，所以autoencoder也可以作为dimensionality reduction的方法（类似PCA）...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://localhost:4000/blog/2020/09/Towards-ML">
  <link rel="alternate" type="application/rss+xml" title="Jiaxuan Li 李嘉轩" href="http://localhost:4000/feed.xml" />
<link rel='stylesheet' id='open-sans-css'  href='//fonts.googleapis.com/css?family=Open+Sans%3A300italic%2C400italic%2C600italic%2C300%2C400%2C600&#038;subset=latin%2Clatin-ext&#038;ver=4.2.4' type='text/css' media='all' />
<link href='https://fonts.googleapis.com/css?family=Titillium+Web:600italic,600,400,400italic' rel='stylesheet' type='text/css'>



<link rel="apple-touch-icon-precomposed" sizes="57x57" href="./images/favicon/apple-touch-icon-57x57.png" />
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="./images/favicon/apple-touch-icon-114x114.png" />
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="./images/favicon/apple-touch-icon-72x72.png" />
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="./images/favicon/apple-touch-icon-144x144.png" />
<link rel="apple-touch-icon-precomposed" sizes="60x60" href="./images/favicon/apple-touch-icon-60x60.png" />
<link rel="apple-touch-icon-precomposed" sizes="120x120" href="./images/favicon/apple-touch-icon-120x120.png" />
<link rel="apple-touch-icon-precomposed" sizes="76x76" href="./images/favicon/apple-touch-icon-76x76.png" />
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="./images/favicon/apple-touch-icon-152x152.png" />
<link rel="icon" type="image/png" href="./images/favicon/favicon-196x196.png" sizes="196x196" />
<link rel="icon" type="image/png" href="./images/favicon/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/png" href="./images/favicon/favicon-32x32.png" sizes="32x32" />
<link rel="icon" type="image/png" href="./images/favicon/favicon-16x16.png" sizes="16x16" />
<link rel="icon" type="image/png" href="./images/favicon/favicon-128.png" sizes="128x128" />
<meta name="application-name" content="&nbsp;"/>
<meta name="msapplication-TileColor" content="#FFFFFF" />
<meta name="msapplication-TileImage" content="./images/favicon/mstile-144x144.png" />
<meta name="msapplication-square70x70logo" content="./images/favicon/mstile-70x70.png" />
<meta name="msapplication-square150x150logo" content="./images/favicon/mstile-150x150.png" />
<meta name="msapplication-wide310x150logo" content="./images/favicon/mstile-310x150.png" />
<meta name="msapplication-square310x310logo" content="./images/favicon/mstile-310x310.png" />





</head>

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Towards Machine Learning | Jiaxuan Li 李嘉轩</title>
<meta name="generator" content="Jekyll v4.2.1" />
<meta property="og:title" content="Towards Machine Learning" />
<meta name="author" content="Jiaxuan Li" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Autoencoder 花式解释AutoEncoder与VAE - Sherlock的文章 - 知乎: 其实AE或者VAE的隐藏层（embedding layer）就是从input中提取出的精华特征，所以autoencoder也可以作为dimensionality reduction的方法（类似PCA）。 为什么Autoencoder可以用来做神经网络的预训练？AutoEncoder: 堆栈自动编码器 Stacked_AutoEncoder - LitoNeo的文章 - 知乎：但是有了batch normalization之后，是否还有预训练的必要？ https://github.com/kstoreyf/anomalies-GAN-HSC ResNet 你必须要知道CNN模型：ResNet - 小小将的文章 - 知乎 Skewness Box-Cox transformation CS 231n: Convolutional Neural Networks for Visual Recognition Syllabus 2017 class video PixelCNN: could complete the data (Bach’s music). Neural density estimation could also generate fake video/voice/images. https://towardsdatascience.com/auto-regressive-generative-models-pixelrnn-pixelcnn-32d192911173 https://google.github.io/tacotron/ Google cloud setup tutorial Lecture2: Linear Classifier only learns one template for one category (the row of the weight matrix). Lecture3: If the image changes a little bit, SVM loss (hinge loss) will not change. You can design your loss function based on how bad you think negative classifications are (linear hinge or squar ed hinge loss). Add an additional term in the loss function as regularization. L1 regularization prefers sparse solutions. Softmax loss (cross-entropy loss): - log probability = - log (normalize(exp(score_of_true_class))). Softmax loss is sensitive to a little change in the input image (thus the score). Actually softmax is a squashing function that turns scores into probability, then cross-entropy loss is used. In DL, you always use analytic gradient (instead of numeric gradient). Getting learning rate correct is the first step in tuning hyper-parameters. Vanilla gradient descent, stochastic gradient descent (SGD), ADAM If we take the whole training set to calculate the loss, gradient, and update parameters, it will take a very long time to iterate over all images. We use stochastic gradient descent (SGD) and minibatch. For each time, we sample a small subset of the training set (called minibatch), and update the parameters based on these images. Feature representation: Extract some features of your images, then flatten features into a 1-D array, and feed it into linear classifier. Histogram of Oriented Gradients (HoG): detecting edge is critical to human vision system. “Visual words” Classical image classification methods first extract features and concatenate features together and feed them to a linear classifier. The feature extraction module will not get updated during training. NN is different, it gets updated during training. Loss and regularization Lecture4: Sigmoid: \(\frac{1}{1+e^{-x}}\) The gradient with respect to a variable should have the same shape as the variable (vectorized operations) Each row of the weight matrix is like a map: where to look for features more neurons = more capacity Actually three FC layers are just like \(f = W_3 \cdot \max(W_2 \cdot \max(W_1\cdot x))\). The notion of “layer” allows us to use efficient vectorized code (matrix multiplies). Lecture5: CNN can also be used for object detection and segmentation. Activation map: the output of a convolution layer (and after activated by some function) In CNN, each filter looks for one type of feature. We use multiple filters/kernels. Filters at the earlier/later layers usually represent low-level/high lever feature. Each filter does convolution in 3 colors (rgb). The depth of output is the number of filters you have. Output size = (N + 2 * padding - F) / stride + 1 The number of filters is often powers of 2: 32, 64, 128. Pooling layer: make representations smaller and more manageable, i.e., direct downsampling. We only do pooling spatially, not in the depth direction. Common one is max pooling. FC: aggregate all features (identified by each Conv layer) and get a score for each category Architecture: [(CONV-RELU) * N – POOL?] * M – (FC–RELU) * K – SOFTMAX. N up to 5, M is large, 0 &lt;= K &lt;= 2. CNN output size formulae Lecture 6: Activation functions: Sigmoid: “kill” gradients when $$ x \gg 1$$ (i.e., gradients go to almost zero, called “saturated”); output is not zero-centered (check the video about this). ReLU (rectified linear unit): doesn’t saturate, computational efficient, converge faster, biologically reasonable. Not zero-centered, saturated in negative x. Leaky ReLU: \(f(x) = \max(0.01 x, x)\), behaves very well. Maxout: \(f(x) = \max(w_1^T x + b_1, w_2^T x + b_2)\). TL;DR: use ReLU (careful about learning rate); try Leaky ReLU/Maxout/ELU; don’t use Sigmoid. Preprocess data: do this before feeding data into CNN Zero-center ( -= np.mean(X)) + normalize (/= np.std(X)) With images, we typically don’t do PCA and whitening. Subtract the mean image ([32, 32, 3] array) or per-channel mean (mean along each channel = 3 numbers) An important point to make about the preprocessing is that any preprocessing statistics (e.g. the data mean) must only be computed on the training data, and then applied to the validation / test data. E.g. computing the mean and subtracting it from every image across the entire dataset and then splitting the data into train/val/test splits would be a mistake. Instead, the mean must be computed only over the training data and then subtracted equally from all splits (train/val/test). Weight initialization (still an active field in DL) Don’t set weights with equal values. Because if every neuron in the network computes the same output, then they will also all compute the same gradients during backpropagation and undergo the exact same parameter updates Don’t initialize with small numbers. a Neural Network layer that has very small weights will during backpropagation compute very small gradients on its data (since this gradient is proportional to the value of the weights). Xavier Initialization: W = np.random.randn(fan_in, fan_out) / np.sqrt(fan_in), i.e., a Gaussian centered at 0 with \(\sigma = 1/\sqrt{N_{in}}\). See here for the derivation. Sparse initialization: see the weights of most neurons to zero, but have several neurons randomly connected (with Gaussian weights). Bias initialization: typically set to zero. The current recommendation is to use ReLU units and use the w = np.random.randn(n) * sqrt(2.0/n) Batch Normalization Batch normalization can be interpreted as doing preprocessing at every layer of the network, but integrated into the network itself in a differentiable manner. For each FC layer (before activation ReLU), we normalize the data on a mini-batch level: subtract the mini-batch mean and divide by the mini-batch std. This is a differentiable function, hence able to backprop. \[\widehat{x}^{(k)}=\frac{x^{(k)}-\mathrm{E}\left[x^{(k)}\right]}{\sqrt{\operatorname{Var}\left[x^{(k)}\right]}}\] A Short Introduction to Entropy, Cross-Entropy and KL-Divergence Entropy: \(H(p) = -\sum_{i}p_i\log(p_i)\), the average information we get from the true distribution. Cross-entropy between two distributions (also a “distance” between two vectors): \(H(p,q) = -\sum_i p_i \log(q_i)\), the average information we get from the assumed distirbution. Kullback-Leibler divergence: $$ D_{KL}(p   q) = H(p,q) - H(p) = \sum_i p_i \log\left(\frac{p_i}{q_i}\right) $$. Softmax loss: to minimize the distance between the true probability distribution and the estimated distribution. For image classification task, the loss becomes \(-\log q_{\text{true}}\). PyTorch Performance Tuning Guide - Szymon Migacz, NVIDIA Optimizing PyTorch code The State of Machine Learning Frameworks in 2019 “Researchers are abandoning TensorFlow and flocking to PyTorch in droves. Meanwhile in industry, Tensorflow is currently the platform of choice, but that may not be true for long.” PyTorch for researchers: simple, great API (pythonic), nice performance. Industry is slower to adopt new technologies than researchers. Researches care about fast iteration, easy-to-use on their own machine. But industry cares about performance (1% faster means a lot to them), ability to transfer to mobile devices, etc. TensorFlow has solutions for all these issues. Deep Learning with Structured Data Chap 1 Drawbacks of DL: large data volume (slow); non-transparent algorithm (well-known); tuning lots of things (overfitting, exploding gradients, and other hyperparameters). Solutions: transfer learning (use a well-trained model as the startpoint for another task); use commercial cloud platforms Structured data (tabular): relational database (rows and columns in a table), SQL. Unstructured data: image, video, audio, also text from HTML/XML/JSON. Many of the celebrated applications of deep learning have been with unstructured data such as images, audio, and text. Gaussian Process in Machine Learning Deep learning and Astrophysics ###ML in cosmology Finding Strong Gravitational Lenses in the DESI DECam Legacy Survey Cluster finder (Song) Another interesting application of deep learning would be cluster finder. I just know that someone is working on it, but have not seen a paper. There is a very short talk at the LSST-UK meeting now: https://lsst-uk.atlassian.net/wiki/download/attachments/650412049/Using_deep_learning_to_search_for_galaxy_clusters.pdf. The idea is pretty straightforward, given a training sample of galaxy clusters down to certain richness/halo mass, is there a network that can select all the clusters in another dataset? Or even better, if the training sample comes with labels like redshift and richness, can the network predict that? This would be a much, much more interesting application…but also it will be much more complicated. Anyway, just another random idea I’d like to write down before I forget… The use of convolutional neural networks for modelling large optically-selected strong galaxy-lens samples Photometric redshifts from SDSS images using a Convolutional Neural Network The use of convolutional neural networks for modelling large optically-selected strong galaxy-lens samples Tidal Features at $0.05 &lt; z &lt; 0.45$ in the Hyper Suprime-Cam Subaru Strategic Program: Properties and Formation Channels Her talk on her paper: Characterizing Tidal Features Across the Mass Scale with HSC The Origin of Faint Tidal Features Around Galaxies in the RESOLVE Survey Identification of Low Surface Brightness Tidal Features in Galaxies Using Convolutional Neural Networks DeepStreaks: identifying fast-moving objects in the Zwicky Transient Facility data with deep learning Photometry of high-redshift blended galaxies using deep learning Gaussian Process in Machine Learning Deep learning for galaxy surface brightness profile fitting An automatic taxonomy of galaxy morphology using unsupervised machine learning The use of convolutional neural networks for modeling large optically-selected strong galaxy-lens samples Photometric redshifts from SDSS images using a Convolutional Neural Network The use of convolutional neural networks for modelling large optically-selected strong galaxy-lens samples" />
<meta property="og:description" content="Autoencoder 花式解释AutoEncoder与VAE - Sherlock的文章 - 知乎: 其实AE或者VAE的隐藏层（embedding layer）就是从input中提取出的精华特征，所以autoencoder也可以作为dimensionality reduction的方法（类似PCA）。 为什么Autoencoder可以用来做神经网络的预训练？AutoEncoder: 堆栈自动编码器 Stacked_AutoEncoder - LitoNeo的文章 - 知乎：但是有了batch normalization之后，是否还有预训练的必要？ https://github.com/kstoreyf/anomalies-GAN-HSC ResNet 你必须要知道CNN模型：ResNet - 小小将的文章 - 知乎 Skewness Box-Cox transformation CS 231n: Convolutional Neural Networks for Visual Recognition Syllabus 2017 class video PixelCNN: could complete the data (Bach’s music). Neural density estimation could also generate fake video/voice/images. https://towardsdatascience.com/auto-regressive-generative-models-pixelrnn-pixelcnn-32d192911173 https://google.github.io/tacotron/ Google cloud setup tutorial Lecture2: Linear Classifier only learns one template for one category (the row of the weight matrix). Lecture3: If the image changes a little bit, SVM loss (hinge loss) will not change. You can design your loss function based on how bad you think negative classifications are (linear hinge or squar ed hinge loss). Add an additional term in the loss function as regularization. L1 regularization prefers sparse solutions. Softmax loss (cross-entropy loss): - log probability = - log (normalize(exp(score_of_true_class))). Softmax loss is sensitive to a little change in the input image (thus the score). Actually softmax is a squashing function that turns scores into probability, then cross-entropy loss is used. In DL, you always use analytic gradient (instead of numeric gradient). Getting learning rate correct is the first step in tuning hyper-parameters. Vanilla gradient descent, stochastic gradient descent (SGD), ADAM If we take the whole training set to calculate the loss, gradient, and update parameters, it will take a very long time to iterate over all images. We use stochastic gradient descent (SGD) and minibatch. For each time, we sample a small subset of the training set (called minibatch), and update the parameters based on these images. Feature representation: Extract some features of your images, then flatten features into a 1-D array, and feed it into linear classifier. Histogram of Oriented Gradients (HoG): detecting edge is critical to human vision system. “Visual words” Classical image classification methods first extract features and concatenate features together and feed them to a linear classifier. The feature extraction module will not get updated during training. NN is different, it gets updated during training. Loss and regularization Lecture4: Sigmoid: \(\frac{1}{1+e^{-x}}\) The gradient with respect to a variable should have the same shape as the variable (vectorized operations) Each row of the weight matrix is like a map: where to look for features more neurons = more capacity Actually three FC layers are just like \(f = W_3 \cdot \max(W_2 \cdot \max(W_1\cdot x))\). The notion of “layer” allows us to use efficient vectorized code (matrix multiplies). Lecture5: CNN can also be used for object detection and segmentation. Activation map: the output of a convolution layer (and after activated by some function) In CNN, each filter looks for one type of feature. We use multiple filters/kernels. Filters at the earlier/later layers usually represent low-level/high lever feature. Each filter does convolution in 3 colors (rgb). The depth of output is the number of filters you have. Output size = (N + 2 * padding - F) / stride + 1 The number of filters is often powers of 2: 32, 64, 128. Pooling layer: make representations smaller and more manageable, i.e., direct downsampling. We only do pooling spatially, not in the depth direction. Common one is max pooling. FC: aggregate all features (identified by each Conv layer) and get a score for each category Architecture: [(CONV-RELU) * N – POOL?] * M – (FC–RELU) * K – SOFTMAX. N up to 5, M is large, 0 &lt;= K &lt;= 2. CNN output size formulae Lecture 6: Activation functions: Sigmoid: “kill” gradients when $$ x \gg 1$$ (i.e., gradients go to almost zero, called “saturated”); output is not zero-centered (check the video about this). ReLU (rectified linear unit): doesn’t saturate, computational efficient, converge faster, biologically reasonable. Not zero-centered, saturated in negative x. Leaky ReLU: \(f(x) = \max(0.01 x, x)\), behaves very well. Maxout: \(f(x) = \max(w_1^T x + b_1, w_2^T x + b_2)\). TL;DR: use ReLU (careful about learning rate); try Leaky ReLU/Maxout/ELU; don’t use Sigmoid. Preprocess data: do this before feeding data into CNN Zero-center ( -= np.mean(X)) + normalize (/= np.std(X)) With images, we typically don’t do PCA and whitening. Subtract the mean image ([32, 32, 3] array) or per-channel mean (mean along each channel = 3 numbers) An important point to make about the preprocessing is that any preprocessing statistics (e.g. the data mean) must only be computed on the training data, and then applied to the validation / test data. E.g. computing the mean and subtracting it from every image across the entire dataset and then splitting the data into train/val/test splits would be a mistake. Instead, the mean must be computed only over the training data and then subtracted equally from all splits (train/val/test). Weight initialization (still an active field in DL) Don’t set weights with equal values. Because if every neuron in the network computes the same output, then they will also all compute the same gradients during backpropagation and undergo the exact same parameter updates Don’t initialize with small numbers. a Neural Network layer that has very small weights will during backpropagation compute very small gradients on its data (since this gradient is proportional to the value of the weights). Xavier Initialization: W = np.random.randn(fan_in, fan_out) / np.sqrt(fan_in), i.e., a Gaussian centered at 0 with \(\sigma = 1/\sqrt{N_{in}}\). See here for the derivation. Sparse initialization: see the weights of most neurons to zero, but have several neurons randomly connected (with Gaussian weights). Bias initialization: typically set to zero. The current recommendation is to use ReLU units and use the w = np.random.randn(n) * sqrt(2.0/n) Batch Normalization Batch normalization can be interpreted as doing preprocessing at every layer of the network, but integrated into the network itself in a differentiable manner. For each FC layer (before activation ReLU), we normalize the data on a mini-batch level: subtract the mini-batch mean and divide by the mini-batch std. This is a differentiable function, hence able to backprop. \[\widehat{x}^{(k)}=\frac{x^{(k)}-\mathrm{E}\left[x^{(k)}\right]}{\sqrt{\operatorname{Var}\left[x^{(k)}\right]}}\] A Short Introduction to Entropy, Cross-Entropy and KL-Divergence Entropy: \(H(p) = -\sum_{i}p_i\log(p_i)\), the average information we get from the true distribution. Cross-entropy between two distributions (also a “distance” between two vectors): \(H(p,q) = -\sum_i p_i \log(q_i)\), the average information we get from the assumed distirbution. Kullback-Leibler divergence: $$ D_{KL}(p   q) = H(p,q) - H(p) = \sum_i p_i \log\left(\frac{p_i}{q_i}\right) $$. Softmax loss: to minimize the distance between the true probability distribution and the estimated distribution. For image classification task, the loss becomes \(-\log q_{\text{true}}\). PyTorch Performance Tuning Guide - Szymon Migacz, NVIDIA Optimizing PyTorch code The State of Machine Learning Frameworks in 2019 “Researchers are abandoning TensorFlow and flocking to PyTorch in droves. Meanwhile in industry, Tensorflow is currently the platform of choice, but that may not be true for long.” PyTorch for researchers: simple, great API (pythonic), nice performance. Industry is slower to adopt new technologies than researchers. Researches care about fast iteration, easy-to-use on their own machine. But industry cares about performance (1% faster means a lot to them), ability to transfer to mobile devices, etc. TensorFlow has solutions for all these issues. Deep Learning with Structured Data Chap 1 Drawbacks of DL: large data volume (slow); non-transparent algorithm (well-known); tuning lots of things (overfitting, exploding gradients, and other hyperparameters). Solutions: transfer learning (use a well-trained model as the startpoint for another task); use commercial cloud platforms Structured data (tabular): relational database (rows and columns in a table), SQL. Unstructured data: image, video, audio, also text from HTML/XML/JSON. Many of the celebrated applications of deep learning have been with unstructured data such as images, audio, and text. Gaussian Process in Machine Learning Deep learning and Astrophysics ###ML in cosmology Finding Strong Gravitational Lenses in the DESI DECam Legacy Survey Cluster finder (Song) Another interesting application of deep learning would be cluster finder. I just know that someone is working on it, but have not seen a paper. There is a very short talk at the LSST-UK meeting now: https://lsst-uk.atlassian.net/wiki/download/attachments/650412049/Using_deep_learning_to_search_for_galaxy_clusters.pdf. The idea is pretty straightforward, given a training sample of galaxy clusters down to certain richness/halo mass, is there a network that can select all the clusters in another dataset? Or even better, if the training sample comes with labels like redshift and richness, can the network predict that? This would be a much, much more interesting application…but also it will be much more complicated. Anyway, just another random idea I’d like to write down before I forget… The use of convolutional neural networks for modelling large optically-selected strong galaxy-lens samples Photometric redshifts from SDSS images using a Convolutional Neural Network The use of convolutional neural networks for modelling large optically-selected strong galaxy-lens samples Tidal Features at $0.05 &lt; z &lt; 0.45$ in the Hyper Suprime-Cam Subaru Strategic Program: Properties and Formation Channels Her talk on her paper: Characterizing Tidal Features Across the Mass Scale with HSC The Origin of Faint Tidal Features Around Galaxies in the RESOLVE Survey Identification of Low Surface Brightness Tidal Features in Galaxies Using Convolutional Neural Networks DeepStreaks: identifying fast-moving objects in the Zwicky Transient Facility data with deep learning Photometry of high-redshift blended galaxies using deep learning Gaussian Process in Machine Learning Deep learning for galaxy surface brightness profile fitting An automatic taxonomy of galaxy morphology using unsupervised machine learning The use of convolutional neural networks for modeling large optically-selected strong galaxy-lens samples Photometric redshifts from SDSS images using a Convolutional Neural Network The use of convolutional neural networks for modelling large optically-selected strong galaxy-lens samples" />
<link rel="canonical" href="http://localhost:4000/blog/2020/09/Towards-ML" />
<meta property="og:url" content="http://localhost:4000/blog/2020/09/Towards-ML" />
<meta property="og:site_name" content="Jiaxuan Li 李嘉轩" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-09-15T11:38:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Towards Machine Learning" />
<meta name="twitter:site" content="@AstroJacobLi" />
<meta name="twitter:creator" content="@Jiaxuan Li" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Jiaxuan Li"},"dateModified":"2020-09-15T11:38:00-04:00","datePublished":"2020-09-15T11:38:00-04:00","description":"Autoencoder 花式解释AutoEncoder与VAE - Sherlock的文章 - 知乎: 其实AE或者VAE的隐藏层（embedding layer）就是从input中提取出的精华特征，所以autoencoder也可以作为dimensionality reduction的方法（类似PCA）。 为什么Autoencoder可以用来做神经网络的预训练？AutoEncoder: 堆栈自动编码器 Stacked_AutoEncoder - LitoNeo的文章 - 知乎：但是有了batch normalization之后，是否还有预训练的必要？ https://github.com/kstoreyf/anomalies-GAN-HSC ResNet 你必须要知道CNN模型：ResNet - 小小将的文章 - 知乎 Skewness Box-Cox transformation CS 231n: Convolutional Neural Networks for Visual Recognition Syllabus 2017 class video PixelCNN: could complete the data (Bach’s music). Neural density estimation could also generate fake video/voice/images. https://towardsdatascience.com/auto-regressive-generative-models-pixelrnn-pixelcnn-32d192911173 https://google.github.io/tacotron/ Google cloud setup tutorial Lecture2: Linear Classifier only learns one template for one category (the row of the weight matrix). Lecture3: If the image changes a little bit, SVM loss (hinge loss) will not change. You can design your loss function based on how bad you think negative classifications are (linear hinge or squar ed hinge loss). Add an additional term in the loss function as regularization. L1 regularization prefers sparse solutions. Softmax loss (cross-entropy loss): - log probability = - log (normalize(exp(score_of_true_class))). Softmax loss is sensitive to a little change in the input image (thus the score). Actually softmax is a squashing function that turns scores into probability, then cross-entropy loss is used. In DL, you always use analytic gradient (instead of numeric gradient). Getting learning rate correct is the first step in tuning hyper-parameters. Vanilla gradient descent, stochastic gradient descent (SGD), ADAM If we take the whole training set to calculate the loss, gradient, and update parameters, it will take a very long time to iterate over all images. We use stochastic gradient descent (SGD) and minibatch. For each time, we sample a small subset of the training set (called minibatch), and update the parameters based on these images. Feature representation: Extract some features of your images, then flatten features into a 1-D array, and feed it into linear classifier. Histogram of Oriented Gradients (HoG): detecting edge is critical to human vision system. “Visual words” Classical image classification methods first extract features and concatenate features together and feed them to a linear classifier. The feature extraction module will not get updated during training. NN is different, it gets updated during training. Loss and regularization Lecture4: Sigmoid: \\(\\frac{1}{1+e^{-x}}\\) The gradient with respect to a variable should have the same shape as the variable (vectorized operations) Each row of the weight matrix is like a map: where to look for features more neurons = more capacity Actually three FC layers are just like \\(f = W_3 \\cdot \\max(W_2 \\cdot \\max(W_1\\cdot x))\\). The notion of “layer” allows us to use efficient vectorized code (matrix multiplies). Lecture5: CNN can also be used for object detection and segmentation. Activation map: the output of a convolution layer (and after activated by some function) In CNN, each filter looks for one type of feature. We use multiple filters/kernels. Filters at the earlier/later layers usually represent low-level/high lever feature. Each filter does convolution in 3 colors (rgb). The depth of output is the number of filters you have. Output size = (N + 2 * padding - F) / stride + 1 The number of filters is often powers of 2: 32, 64, 128. Pooling layer: make representations smaller and more manageable, i.e., direct downsampling. We only do pooling spatially, not in the depth direction. Common one is max pooling. FC: aggregate all features (identified by each Conv layer) and get a score for each category Architecture: [(CONV-RELU) * N – POOL?] * M – (FC–RELU) * K – SOFTMAX. N up to 5, M is large, 0 &lt;= K &lt;= 2. CNN output size formulae Lecture 6: Activation functions: Sigmoid: “kill” gradients when $$ x \\gg 1$$ (i.e., gradients go to almost zero, called “saturated”); output is not zero-centered (check the video about this). ReLU (rectified linear unit): doesn’t saturate, computational efficient, converge faster, biologically reasonable. Not zero-centered, saturated in negative x. Leaky ReLU: \\(f(x) = \\max(0.01 x, x)\\), behaves very well. Maxout: \\(f(x) = \\max(w_1^T x + b_1, w_2^T x + b_2)\\). TL;DR: use ReLU (careful about learning rate); try Leaky ReLU/Maxout/ELU; don’t use Sigmoid. Preprocess data: do this before feeding data into CNN Zero-center ( -= np.mean(X)) + normalize (/= np.std(X)) With images, we typically don’t do PCA and whitening. Subtract the mean image ([32, 32, 3] array) or per-channel mean (mean along each channel = 3 numbers) An important point to make about the preprocessing is that any preprocessing statistics (e.g. the data mean) must only be computed on the training data, and then applied to the validation / test data. E.g. computing the mean and subtracting it from every image across the entire dataset and then splitting the data into train/val/test splits would be a mistake. Instead, the mean must be computed only over the training data and then subtracted equally from all splits (train/val/test). Weight initialization (still an active field in DL) Don’t set weights with equal values. Because if every neuron in the network computes the same output, then they will also all compute the same gradients during backpropagation and undergo the exact same parameter updates Don’t initialize with small numbers. a Neural Network layer that has very small weights will during backpropagation compute very small gradients on its data (since this gradient is proportional to the value of the weights). Xavier Initialization: W = np.random.randn(fan_in, fan_out) / np.sqrt(fan_in), i.e., a Gaussian centered at 0 with \\(\\sigma = 1/\\sqrt{N_{in}}\\). See here for the derivation. Sparse initialization: see the weights of most neurons to zero, but have several neurons randomly connected (with Gaussian weights). Bias initialization: typically set to zero. The current recommendation is to use ReLU units and use the w = np.random.randn(n) * sqrt(2.0/n) Batch Normalization Batch normalization can be interpreted as doing preprocessing at every layer of the network, but integrated into the network itself in a differentiable manner. For each FC layer (before activation ReLU), we normalize the data on a mini-batch level: subtract the mini-batch mean and divide by the mini-batch std. This is a differentiable function, hence able to backprop. \\[\\widehat{x}^{(k)}=\\frac{x^{(k)}-\\mathrm{E}\\left[x^{(k)}\\right]}{\\sqrt{\\operatorname{Var}\\left[x^{(k)}\\right]}}\\] A Short Introduction to Entropy, Cross-Entropy and KL-Divergence Entropy: \\(H(p) = -\\sum_{i}p_i\\log(p_i)\\), the average information we get from the true distribution. Cross-entropy between two distributions (also a “distance” between two vectors): \\(H(p,q) = -\\sum_i p_i \\log(q_i)\\), the average information we get from the assumed distirbution. Kullback-Leibler divergence: $$ D_{KL}(p   q) = H(p,q) - H(p) = \\sum_i p_i \\log\\left(\\frac{p_i}{q_i}\\right) $$. Softmax loss: to minimize the distance between the true probability distribution and the estimated distribution. For image classification task, the loss becomes \\(-\\log q_{\\text{true}}\\). PyTorch Performance Tuning Guide - Szymon Migacz, NVIDIA Optimizing PyTorch code The State of Machine Learning Frameworks in 2019 “Researchers are abandoning TensorFlow and flocking to PyTorch in droves. Meanwhile in industry, Tensorflow is currently the platform of choice, but that may not be true for long.” PyTorch for researchers: simple, great API (pythonic), nice performance. Industry is slower to adopt new technologies than researchers. Researches care about fast iteration, easy-to-use on their own machine. But industry cares about performance (1% faster means a lot to them), ability to transfer to mobile devices, etc. TensorFlow has solutions for all these issues. Deep Learning with Structured Data Chap 1 Drawbacks of DL: large data volume (slow); non-transparent algorithm (well-known); tuning lots of things (overfitting, exploding gradients, and other hyperparameters). Solutions: transfer learning (use a well-trained model as the startpoint for another task); use commercial cloud platforms Structured data (tabular): relational database (rows and columns in a table), SQL. Unstructured data: image, video, audio, also text from HTML/XML/JSON. Many of the celebrated applications of deep learning have been with unstructured data such as images, audio, and text. Gaussian Process in Machine Learning Deep learning and Astrophysics ###ML in cosmology Finding Strong Gravitational Lenses in the DESI DECam Legacy Survey Cluster finder (Song) Another interesting application of deep learning would be cluster finder. I just know that someone is working on it, but have not seen a paper. There is a very short talk at the LSST-UK meeting now: https://lsst-uk.atlassian.net/wiki/download/attachments/650412049/Using_deep_learning_to_search_for_galaxy_clusters.pdf. The idea is pretty straightforward, given a training sample of galaxy clusters down to certain richness/halo mass, is there a network that can select all the clusters in another dataset? Or even better, if the training sample comes with labels like redshift and richness, can the network predict that? This would be a much, much more interesting application…but also it will be much more complicated. Anyway, just another random idea I’d like to write down before I forget… The use of convolutional neural networks for modelling large optically-selected strong galaxy-lens samples Photometric redshifts from SDSS images using a Convolutional Neural Network The use of convolutional neural networks for modelling large optically-selected strong galaxy-lens samples Tidal Features at $0.05 &lt; z &lt; 0.45$ in the Hyper Suprime-Cam Subaru Strategic Program: Properties and Formation Channels Her talk on her paper: Characterizing Tidal Features Across the Mass Scale with HSC The Origin of Faint Tidal Features Around Galaxies in the RESOLVE Survey Identification of Low Surface Brightness Tidal Features in Galaxies Using Convolutional Neural Networks DeepStreaks: identifying fast-moving objects in the Zwicky Transient Facility data with deep learning Photometry of high-redshift blended galaxies using deep learning Gaussian Process in Machine Learning Deep learning for galaxy surface brightness profile fitting An automatic taxonomy of galaxy morphology using unsupervised machine learning The use of convolutional neural networks for modeling large optically-selected strong galaxy-lens samples Photometric redshifts from SDSS images using a Convolutional Neural Network The use of convolutional neural networks for modelling large optically-selected strong galaxy-lens samples","headline":"Towards Machine Learning","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/2020/09/Towards-ML"},"url":"http://localhost:4000/blog/2020/09/Towards-ML"}</script>
<!-- End Jekyll SEO tag -->

  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Jiaxuan Li 李嘉轩</a>


    <nav class="site-nav">

      <a href="#" class="menu-icon menu.open">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>  

    <div class="trigger"><h1>Main Navigation</h1>

 <ul class="menu">

    
    
     <li><a href="/about/" class="page-link">About</a>
    
    </li>
    
    
     <li><a href="/cv/" class="page-link">CV</a>
    
    </li>
    
    
     <li><a href="/research/" class="page-link">Research</a>
    
    </li>
    
    
     <li><a href="/blog/" class="page-link">Blog</a>
    
    </li>
    
    
     <li><a href="/portfolio/" class="page-link">Gallery</a>
    
    </li>
    
    
    <li><a href="/miscellany/" class="page-link">Miscellany</a>
    <ul class="sub-menu">
    
    <li><a href="/miscellany/photography">Photography</a></li>
    
    <li><a href="/miscellany/cooking/">Cooking</a></li>
    
    <li><a href="/miscellany/links">Links</a></li>
    
    </ul>
    
    </li>
    
    </ul>


     </div>  
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">
  <header class="post-header">
    <h1 class="post-title">Towards Machine Learning</h1>
    <p class="post-meta">Posted on September 15, 2020 by  Jiaxuan Li  

  in
  
  <a href="/categories/#paper" title="paper">paper</a>&nbsp;
  


</p>
  </header>

  <article class="post-content">
    <hr />

<h3 id="autoencoder">Autoencoder</h3>

<ul>
  <li>
    <p><a href="https://zhuanlan.zhihu.com/p/27549418">花式解释AutoEncoder与VAE - Sherlock的文章 - 知乎</a>: 其实AE或者VAE的隐藏层（embedding layer）就是从input中提取出的精华特征，所以autoencoder也可以作为dimensionality reduction的方法（类似PCA）。</p>
  </li>
  <li>
    <p><a href="https://zhuanlan.zhihu.com/p/83331286"><strong>为什么Autoencoder可以用来做神经网络的预训练？</strong>AutoEncoder: 堆栈自动编码器 Stacked_AutoEncoder - LitoNeo的文章 - 知乎</a>：但是有了batch normalization之后，是否还有预训练的必要？</p>
  </li>
</ul>

<p>https://github.com/kstoreyf/anomalies-GAN-HSC</p>

<h3 id="resnet">ResNet</h3>

<ul>
  <li><a href="https://zhuanlan.zhihu.com/p/31852747">你必须要知道CNN模型：ResNet - 小小将的文章 - 知乎</a></li>
</ul>

<h3 id="skewness">Skewness</h3>

<p><a href="http://onlinestatbook.com/2/transformations/box-cox.html">Box-Cox transformation</a></p>

<h3 id="cs-231n-convolutional-neural-networks-for-visual-recognition"><a href="http://cs231n.stanford.edu/index.html">CS 231n: Convolutional Neural Networks for Visual Recognition</a></h3>

<ul>
  <li><a href="http://cs231n.stanford.edu/syllabus.html">Syllabus</a></li>
  <li>
    <p><a href="https://www.youtube.com/watch?v=h7iBpEHGVNc&amp;list=PL3FW7Lu3i5JvHM8ljYj-zLfQRF3EO8sYv&amp;index=3">2017 class video</a></p>
  </li>
  <li>
    <p><a href="https://towardsdatascience.com/auto-regressive-generative-models-pixelrnn-pixelcnn-32d192911173">PixelCNN</a>: could complete the data (Bach’s music). Neural density estimation could also generate fake video/voice/images.</p>
  </li>
  <li>
    <p>https://towardsdatascience.com/auto-regressive-generative-models-pixelrnn-pixelcnn-32d192911173</p>
  </li>
  <li>
    <p>https://google.github.io/tacotron/</p>
  </li>
  <li>
    <p><a href="https://github.com/cs231n/gcloud">Google cloud setup tutorial</a></p>
  </li>
  <li>
    <p>Lecture2:</p>

    <ul>
      <li>Linear Classifier only learns one template for one category (the row of the weight matrix).</li>
    </ul>
  </li>
  <li>
    <p>Lecture3:</p>

    <ul>
      <li>If the image changes a little bit, SVM loss (<strong>hinge loss</strong>) will not change.</li>
      <li>You can design your loss function based on how bad you think negative classifications are (linear hinge or squar ed hinge loss).</li>
      <li>Add an additional term in the loss function as <strong>regularization</strong>. L1 regularization prefers sparse solutions.</li>
      <li>Softmax loss (<a href="https://www.youtube.com/watch?v=ErfnhcEV1O8"><strong>cross-entropy loss</strong></a>):  - log probability = - log (normalize(exp(score_of_true_class))). Softmax loss is sensitive to a little change in the input image (thus the score). Actually <code class="language-plaintext highlighter-rouge">softmax</code> is a squashing function that turns scores into probability, then cross-entropy loss is used.</li>
      <li>In DL, you always use analytic gradient (instead of numeric gradient).</li>
      <li>Getting learning rate correct is the first step in tuning hyper-parameters.</li>
      <li>Vanilla gradient descent, stochastic gradient descent (SGD), ADAM</li>
      <li>If we take the whole training set to calculate the loss, gradient, and update parameters, it will take a very long time to iterate over all images. We use stochastic gradient descent (SGD) and <strong>minibatch</strong>. For each time, we sample a small subset of the training set (called minibatch), and update the parameters based on these images.</li>
      <li><strong>Feature representation</strong>:
        <ul>
          <li>Extract some features of your images, then flatten features into a 1-D array, and feed it into linear classifier.</li>
          <li>Histogram of Oriented Gradients (HoG): detecting edge is critical to human vision system.</li>
          <li>“Visual words”</li>
          <li>Classical image classification methods first extract features and concatenate features together and feed them to a linear classifier. The feature extraction module will not get updated during training. NN is different, it gets updated during training.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<dl class="wp-caption aligncenter" style="width: 400px">

<dt><a href=""><img class="" src="/images/astro-ph/CS231n-Lec3-1.png" alt="Loss and regularization" /></a></dt>

<dd>Loss and regularization</dd>
</dl>

<ul>
  <li>
    <p>Lecture4:</p>

    <ul>
      <li>Sigmoid: \(\frac{1}{1+e^{-x}}\)</li>
      <li>The gradient with respect to a variable should have the same shape as the variable (vectorized operations)</li>
      <li>Each row of the weight matrix is like a map: where to look for features</li>
      <li>more neurons = more capacity</li>
      <li>Actually three FC layers are just like \(f = W_3 \cdot \max(W_2 \cdot \max(W_1\cdot x))\). The notion of “layer” allows us to use efficient vectorized code (matrix multiplies).</li>
    </ul>
  </li>
  <li>
    <p>Lecture5:</p>

    <ul>
      <li>CNN can also be used for object detection and segmentation.</li>
      <li>Activation map: the output of a convolution layer (and after activated by some function)</li>
      <li>In CNN, each filter looks for one type of feature. We use multiple filters/kernels.</li>
      <li>Filters at the earlier/later layers usually represent low-level/high lever feature. Each filter does convolution in 3 colors (rgb). The depth of output is the number of filters you have.</li>
      <li><strong>Output size = (N + 2 * padding - F) / stride + 1</strong>
The number of filters is often powers of 2: 32, 64, 128.</li>
      <li>Pooling layer: make representations smaller and more manageable, i.e., <strong>direct downsampling</strong>. We only do pooling spatially, not in the depth direction. Common one is <strong>max pooling</strong>.</li>
      <li>FC: aggregate all features (identified by each Conv layer) and get a score for each category</li>
      <li>Architecture: <strong>[(CONV-RELU) * N – POOL?] * M – (FC–RELU) * K – SOFTMAX</strong>.
<u>N up to 5, M is large, 0 &lt;= K &lt;= 2</u>.</li>
    </ul>
  </li>
</ul>

<dl class="wp-caption aligncenter" style="width: 400px">

<dt><a href=""><img class="" src="/images/astro-ph/CS231n-Lec4-CNN.png" alt="CNN output size formulae" /></a></dt>

<dd>CNN output size formulae</dd>
</dl>

<ul>
  <li>
    <p>Lecture 6:</p>

    <ul>
      <li>
        <p>Activation functions:</p>

        <ul>
          <li>
            <table>
              <tbody>
                <tr>
                  <td>Sigmoid: “kill” gradients when $$</td>
                  <td>x</td>
                  <td>\gg 1$$ (i.e., gradients go to almost zero, called “saturated”); output is not zero-centered (check the video about this).</td>
                </tr>
              </tbody>
            </table>
          </li>
          <li>ReLU (rectified linear unit): doesn’t saturate, computational efficient, converge faster, biologically reasonable. Not zero-centered, saturated in negative x.</li>
          <li>Leaky ReLU: \(f(x) = \max(0.01 x, x)\), behaves very well.</li>
          <li>Maxout: \(f(x) = \max(w_1^T x + b_1, w_2^T x + b_2)\).</li>
          <li>TL;DR: use ReLU (careful about learning rate); try Leaky ReLU/Maxout/ELU; don’t use Sigmoid.</li>
        </ul>
      </li>
      <li>
        <p>Preprocess data: do this before feeding data into CNN</p>

        <ul>
          <li>Zero-center ( <code class="language-plaintext highlighter-rouge">-= np.mean(X)</code>) + normalize (<code class="language-plaintext highlighter-rouge">/= np.std(X)</code>)</li>
          <li>With images, we typically don’t do PCA and whitening.</li>
          <li>Subtract the mean image ([32, 32, 3] array) or per-channel mean (mean along each channel = 3 numbers)</li>
          <li>An important point to make about the preprocessing is that any preprocessing statistics (e.g. the data mean) must only be computed on the training data, and then applied to the validation / test data. E.g. computing the mean and subtracting it from every image across the entire dataset and then splitting the data into train/val/test splits would be a mistake. Instead, the mean must be computed only over the training data and then subtracted equally from all splits (train/val/test).</li>
        </ul>
      </li>
      <li>
        <p>Weight initialization (still an active field in DL)</p>

        <ul>
          <li>Don’t set weights with equal values. Because if every neuron in the network computes the same output, then they will also all compute the same gradients during backpropagation and undergo the exact same parameter updates</li>
          <li>Don’t initialize with small numbers. a Neural Network layer that has very small weights will during backpropagation compute very small gradients on its data (since this gradient is proportional to the value of the weights).</li>
          <li><strong>Xavier Initialization</strong>: <code class="language-plaintext highlighter-rouge">W = np.random.randn(fan_in, fan_out) / np.sqrt(fan_in)</code>, i.e., a Gaussian centered at 0 with \(\sigma = 1/\sqrt{N_{in}}\). See <a href="https://cs231n.github.io/neural-networks-2/#reg">here</a> for the derivation.</li>
          <li><strong>Sparse initialization</strong>: see the weights of most neurons to zero, but have several neurons randomly connected (with Gaussian weights).</li>
          <li>Bias initialization: typically set to zero.</li>
          <li>The current recommendation is to use ReLU units and use the <code class="language-plaintext highlighter-rouge">w = np.random.randn(n) * sqrt(2.0/n)</code></li>
        </ul>
      </li>
      <li>
        <p><a href="https://towardsdatascience.com/batch-normalization-in-neural-networks-1ac91516821c">Batch Normalization</a></p>

        <ul>
          <li>
            <p>Batch normalization can be interpreted as doing preprocessing at every layer of the network, but integrated into the network itself in a differentiable manner.</p>
          </li>
          <li>
            <p>For each FC layer (before activation ReLU), we normalize the data on a mini-batch level: subtract the mini-batch mean and divide by the mini-batch std. This is a differentiable function, hence able to backprop.</p>

\[\widehat{x}^{(k)}=\frac{x^{(k)}-\mathrm{E}\left[x^{(k)}\right]}{\sqrt{\operatorname{Var}\left[x^{(k)}\right]}}\]
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="a-short-introduction-to-entropy-cross-entropy-and-kl-divergence"><a href="https://www.youtube.com/watch?v=ErfnhcEV1O8">A Short Introduction to Entropy, Cross-Entropy and KL-Divergence</a></h3>

<ul>
  <li>Entropy: \(H(p) = -\sum_{i}p_i\log(p_i)\), the average information we get from the true distribution.</li>
  <li>Cross-entropy between two distributions (also a “distance” between two vectors): \(H(p,q) = -\sum_i p_i \log(q_i)\), the average information we get from the assumed distirbution.</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Kullback-Leibler divergence: $$ D_{KL}(p</td>
          <td> </td>
          <td>q) = H(p,q) - H(p) = \sum_i p_i \log\left(\frac{p_i}{q_i}\right) $$.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>Softmax loss: to minimize the distance between the true probability distribution and the estimated distribution. For image classification task, the loss becomes \(-\log q_{\text{true}}\).</li>
</ul>

<h3 id="pytorch-performance-tuning-guide---szymon-migacz-nvidia"><a href="https://www.youtube.com/watch?v=9mS1fIYj1So">PyTorch Performance Tuning Guide - Szymon Migacz, NVIDIA</a></h3>

<dl class="wp-caption alignright" style="width: 350px">

<dt><a href=""><img class="" src="https://pbs.twimg.com/media/Ego_hTIUwAARnS6?format=png&amp;name=900x900" alt="Optimizing PyTorch code" /></a></dt>

<dd>Optimizing PyTorch code</dd>
</dl>

<h3 id="the-state-of-machine-learning-frameworks-in-2019"><a href="https://thegradient.pub/state-of-ml-frameworks-2019-pytorch-dominates-research-tensorflow-dominates-industry/">The State of Machine Learning Frameworks in 2019</a></h3>

<ul>
  <li>“Researchers are abandoning TensorFlow and flocking to PyTorch in droves. Meanwhile in industry, Tensorflow is currently the platform of choice, but that may not be true for long.”</li>
  <li>PyTorch for researchers: simple, great API (pythonic), nice performance.</li>
  <li>Industry is slower to adopt new technologies than researchers. Researches care about fast iteration, easy-to-use on their own machine. But industry cares about performance (1% faster means a lot to them), ability to transfer to mobile devices, etc. TensorFlow has solutions for all these issues.</li>
</ul>

<h3 id="deep-learning-with-structured-data"><a href="https://livebook.manning.com/book/deep-learning-with-structured-data/chapter-1/v-6/6">Deep Learning with Structured Data</a></h3>

<ul>
  <li>Chap 1
    <ul>
      <li>Drawbacks of DL: large data volume (slow); non-transparent algorithm (well-known); tuning lots of things (overfitting, exploding gradients, and other hyperparameters).</li>
      <li>Solutions: transfer learning (use a well-trained model as the startpoint for another task); use commercial cloud platforms</li>
      <li>Structured data (tabular): relational database (<strong>rows and columns</strong> in a table), SQL. Unstructured data: image, video, audio, also text from HTML/XML/JSON. Many of the celebrated applications of deep learning have been with unstructured data such as images, audio, and text.</li>
    </ul>
  </li>
</ul>

<h3 id="gaussian-process-in-machine-learning"><a href="http://www.gaussianprocess.org/gpml/chapters/RW.pdf">Gaussian Process in Machine Learning</a></h3>

<h2 id="deep-learning-and-astrophysics">Deep learning and Astrophysics</h2>

<p>###<a href="https://github.com/georgestein/ml-in-cosmology">ML in cosmology</a></p>

<h3 id="finding-strong-gravitational-lenses-in-the-desi-decam-legacy-survey"><a href="https://arxiv.org/pdf/1906.00970.pdf">Finding Strong Gravitational Lenses in the DESI DECam Legacy Survey</a></h3>

<h3 id="cluster-finder-song">Cluster finder (Song)</h3>

<p>Another interesting application of deep learning would be cluster finder.  I just know that someone is working on it, but have not seen a paper.  There is a very short talk at the LSST-UK meeting now:  https://lsst-uk.atlassian.net/wiki/download/attachments/650412049/Using_deep_learning_to_search_for_galaxy_clusters.pdf. The idea is pretty straightforward, given a training sample of galaxy clusters down to certain richness/halo mass, is there a network that can select all the clusters in another dataset?  Or even better, if the training sample comes with labels like redshift and richness, can the network predict that?
This would be a much, much more interesting application…but also it will be much more complicated.
Anyway, just another random idea I’d like to write down before I forget…</p>

<h3 id="the-use-of-convolutional-neural-networks-for-modelling-large-optically-selected-strong-galaxy-lens-samples"><a href="https://arxiv.org/pdf/1904.06199v1.pdf">The use of convolutional neural networks for modelling large optically-selected strong galaxy-lens samples</a></h3>

<h3 id="photometric-redshifts-from-sdss-images-using-a-convolutional-neural-network"><a href="https://arxiv.org/pdf/1806.06607.pdf">Photometric redshifts from SDSS images using a Convolutional Neural Network</a></h3>

<h3 id="the-use-of-convolutional-neural-networks-for-modelling-large-optically-selected-strong-galaxy-lens-samples-1"><a href="https://arxiv.org/abs/1904.06199v1">The use of convolutional neural networks for modelling large optically-selected strong galaxy-lens samples</a></h3>

<h3 id="tidal-features-at-005--z--045-in-the-hyper-suprime-cam-subaru-strategic-program-properties-and-formation-channels"><a href="https://arxiv.org/abs/1805.05970">Tidal Features at $0.05 &lt; z &lt; 0.45$ in the Hyper Suprime-Cam Subaru Strategic Program: Properties and Formation Channels</a></h3>
<ul>
  <li>Her talk on her paper: <a href="https://www.youtube.com/watch?v=sdQYZFN7dH8">Characterizing Tidal Features Across the Mass Scale with HSC</a></li>
</ul>

<h3 id="the-origin-of-faint-tidal-features-around-galaxies-in-the-resolve-survey"><a href="https://arxiv.org/abs/1803.05447">The Origin of Faint Tidal Features Around Galaxies in the RESOLVE Survey</a></h3>

<h3 id="identification-of-low-surface-brightness-tidal-features-in-galaxies-using-convolutional-neural-networks"><a href="https://arxiv.org/abs/1811.11616">Identification of Low Surface Brightness Tidal Features in Galaxies Using Convolutional Neural Networks</a></h3>

<h3 id="deepstreaks-identifying-fast-moving-objects-in-the-zwicky-transient-facility-data-with-deep-learning"><a href="https://arxiv.org/abs/1904.05920v1">DeepStreaks: identifying fast-moving objects in the Zwicky Transient Facility data with deep learning</a></h3>

<h3 id="photometry-of-high-redshift-blended-galaxies-using-deep-learning"><a href="https://arxiv.org/pdf/1905.01324.pdf">Photometry of high-redshift blended galaxies using deep learning</a></h3>

<h3 id="gaussian-process-in-machine-learning-1"><a href="http://www.gaussianprocess.org/gpml/chapters/RW.pdf">Gaussian Process in Machine Learning</a></h3>

<h3 id="deep-learning-for-galaxy-surface-brightness-profile-fitting"><a href="https://academic.oup.com/mnras/article/475/1/894/4725057">Deep learning for galaxy surface brightness profile fitting</a></h3>

<h3 id="an-automatic-taxonomy-of-galaxy-morphology-using-unsupervised-machine-learning"><a href="https://academic.oup.com/mnras/article/473/1/1108/4159372">An automatic taxonomy of galaxy morphology using unsupervised machine learning</a></h3>

<h3 id="the-use-of-convolutional-neural-networks-for-modeling-large-optically-selected-strong-galaxy-lens-samples"><a href="https://arxiv.org/pdf/1904.06199v1.pdf">The use of convolutional neural networks for modeling large optically-selected strong galaxy-lens samples</a></h3>

<h3 id="photometric-redshifts-from-sdss-images-using-a-convolutional-neural-network-1"><a href="https://arxiv.org/pdf/1806.06607.pdf">Photometric redshifts from SDSS images using a Convolutional Neural Network</a></h3>

<h3 id="the-use-of-convolutional-neural-networks-for-modelling-large-optically-selected-strong-galaxy-lens-samples-2"><a href="https://arxiv.org/abs/1904.06199v1">The use of convolutional neural networks for modelling large optically-selected strong galaxy-lens samples</a></h3>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

<!--     <h2 class="footer-heading">Jiaxuan Li 李嘉轩</h2> -->

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-2">
        <br>
        <ul class="contact-list">
          <li><strong>Jiaxuan Li 李嘉轩</strong></li>
          <li>Graduate Student</li>
          <li><a href="mailto:jiaxuanl@princeton.edu">jiaxuanl@princeton.edu</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <br>
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/AstroJacobLi">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">AstroJacobLi</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/AstroJacobLi">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">AstroJacobLi</span>
            </a>
          </li>
          
          
          <li>
            <a href="https://orcid.org"><img alt="ORCID logo" src="https://orcid.org/sites/default/files/images/orcid_16x16.png" width="16" height="16" hspace="0" /></a> <a href="https://orcid.org/0000-0001-9592-4190"> <font size="-1">0000-0001-9592-4190</font></a>
          </li>

          

          
        </ul>
      </div>

      <div class="footer-col  footer-col-5">
        <br>
         <p class="text">
          Department of Astrophysical Sciences<br>
          012 Peyton Hall, 4 Ivy Lane,<br>
          Princeton, NJ 08544, USA<br>
      </div>

      <div class="footer-col  footer-col-2">
         <script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=5umlf3qf2sp&amp;m=0&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=33" async="async"></script>
      </div>

    </div>

  </div>

</footer>

  </body>

</html>
<!-- d.s.m.s.050600.062508.030515.080516.030818 | "Baby, I'm Yours" -->